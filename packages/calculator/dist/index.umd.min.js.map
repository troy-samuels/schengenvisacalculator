{"version":3,"file":"index.umd.min.js","sources":["../src/calculator/robust-schengen-calculator.ts","../src/validators/cumulative-validation.ts","../src/data/countries.ts","../src/validators/date-overlap-validator.ts"],"sourcesContent":["import { differenceInDays, subDays, addDays, startOfDay, isValid, isLeapYear, format } from \"date-fns\"\n\nimport type {\n  Trip,\n  ComplianceResult,\n  DayBreakdown,\n  ValidationError,\n  RollingWindowCheck,\n  PlannedTripValidation,\n  TripValidationResult\n} from '../types'\n\n/**\n * Robust Schengen Calculator implementing exact 180-day rolling window rules\n * \n * Key Schengen Rules:\n * 1. Maximum 90 days in any 180-day period\n * 2. The 180-day period is ROLLING - calculated from any given date backward\n * 3. Entry and exit days both count as stay days\n * 4. Days must be calculated for EVERY day, not just trip endpoints\n */\nexport class RobustSchengenCalculator {\n  private static readonly MAX_DAYS_IN_PERIOD = 90\n  private static readonly ROLLING_PERIOD_DAYS = 180\n\n  /**\n   * Calculate compliance using exact rolling window algorithm\n   * This checks compliance for EVERY day in the period, not just trip endpoints\n   * Enhanced with edge case handling for leap years, timezones, and boundary conditions\n   */\n  static calculateExactCompliance(trips: Trip[], referenceDate: Date = new Date()): ComplianceResult {\n    try {\n      // Enhanced input validation\n      if (!Array.isArray(trips)) {\n        throw new Error('Trips must be an array')\n      }\n\n      if (!referenceDate || !isValid(referenceDate)) {\n        throw new Error('Reference date must be a valid Date object')\n      }\n\n      // Validate reference date is not in extreme future/past\n      const now = new Date()\n      const tenYearsAgo = subDays(now, 365 * 10)\n      const fiveYearsFromNow = addDays(now, 365 * 5)\n      \n      if (referenceDate < tenYearsAgo || referenceDate > fiveYearsFromNow) {\n        console.warn(`Reference date ${format(referenceDate, 'yyyy-MM-dd')} is outside reasonable range`)\n      }\n\n      // Normalize reference date to start of day (UTC-agnostic)\n      const normalizedRefDate = this.normalizeToStartOfDay(referenceDate)\n      const periodStart = this.calculatePeriodStart(normalizedRefDate)\n      \n      // Validate and normalize all trips\n      const validTrips = this.validateAndNormalizeTrips(trips)\n      \n      // Handle empty trips case\n      if (validTrips.length === 0) {\n        return {\n          totalDaysUsed: 0,\n          daysRemaining: this.MAX_DAYS_IN_PERIOD,\n          isCompliant: true,\n          overstayDays: 0,\n          referenceDate: normalizedRefDate,\n          periodStart,\n          periodEnd: normalizedRefDate,\n          detailedBreakdown: []\n        }\n      }\n      \n      // Create a map of all days with stays\n      const dailyStays = this.createDailyStayMap(validTrips, periodStart, normalizedRefDate)\n      \n      // Calculate rolling compliance for each day\n      const rollingChecks = this.calculateRollingComplianceForAllDays(\n        dailyStays,\n        periodStart,\n        normalizedRefDate\n      )\n      \n      // Validate rolling checks\n      if (rollingChecks.length === 0) {\n        throw new Error('Failed to generate rolling compliance checks')\n      }\n      \n      // Find the maximum violation and current status\n      const maxViolation = Math.max(...rollingChecks.map(check => check.overstayDays))\n      const currentCompliance = rollingChecks[rollingChecks.length - 1]\n      \n      if (!currentCompliance) {\n        throw new Error('Failed to get current compliance status')\n      }\n      \n      // Generate detailed breakdown\n      const detailedBreakdown = this.generateDetailedBreakdown(\n        dailyStays,\n        rollingChecks,\n        periodStart,\n        normalizedRefDate\n      )\n      \n      const result = {\n        totalDaysUsed: currentCompliance.daysInWindow,\n        daysRemaining: Math.max(0, this.MAX_DAYS_IN_PERIOD - currentCompliance.daysInWindow),\n        isCompliant: maxViolation === 0,\n        overstayDays: maxViolation,\n        referenceDate: normalizedRefDate,\n        periodStart,\n        periodEnd: normalizedRefDate,\n        detailedBreakdown\n      }\n\n      // Final validation of result\n      if (result.totalDaysUsed < 0 || result.daysRemaining < 0) {\n        console.error('Invalid calculation result:', result)\n        throw new Error('Calculation produced invalid negative values')\n      }\n\n      return result\n    } catch (error) {\n      console.error('Error in calculateExactCompliance:', error)\n      \n      // Return safe fallback\n      const normalizedRefDate = startOfDay(referenceDate)\n      return {\n        totalDaysUsed: 0,\n        daysRemaining: this.MAX_DAYS_IN_PERIOD,\n        isCompliant: true,\n        overstayDays: 0,\n        referenceDate: normalizedRefDate,\n        periodStart: subDays(normalizedRefDate, this.ROLLING_PERIOD_DAYS - 1),\n        periodEnd: normalizedRefDate,\n        detailedBreakdown: []\n      }\n    }\n  }\n\n  /**\n   * Calculate the exact number of days used in any 180-day window ending on a specific date\n   */\n  static calculateDaysInWindow(trips: Trip[], endDate: Date): number {\n    if (!isValid(endDate)) {\n      throw new Error('End date must be valid')\n    }\n    \n    const normalizedEndDate = this.normalizeToStartOfDay(endDate)\n    const windowStart = this.calculatePeriodStart(normalizedEndDate)\n    \n    let totalDays = 0\n    \n    for (const trip of trips) {\n      if (!isValid(trip.startDate) || !isValid(trip.endDate)) {\n        console.warn(`Skipping trip ${trip.id} with invalid dates`)\n        continue\n      }\n      \n      const tripStart = this.normalizeToStartOfDay(trip.startDate)\n      const tripEnd = this.normalizeToStartOfDay(trip.endDate)\n      \n      // Calculate overlap with the window (inclusive of both start and end)\n      const overlapStart = tripStart > windowStart ? tripStart : windowStart\n      const overlapEnd = tripEnd < normalizedEndDate ? tripEnd : normalizedEndDate\n      \n      if (overlapStart <= overlapEnd) {\n        // Both start and end days count, so we add 1\n        const daysInOverlap = differenceInDays(overlapEnd, overlapStart) + 1\n        \n        // Validate the calculated days\n        if (daysInOverlap < 0) {\n          console.error(`Negative days calculated for trip ${trip.id}`)\n          continue\n        }\n        \n        totalDays += daysInOverlap\n      }\n    }\n    \n    return totalDays\n  }\n\n  /**\n   * Check if a planned trip would violate the 90/180 rule\n   */\n  static validatePlannedTrip(\n    existingTrips: Trip[],\n    plannedTrip: Trip\n  ): PlannedTripValidation {\n    const allTrips = [...existingTrips, plannedTrip]\n    \n    // Check compliance for every day of the planned trip\n    let currentDate = startOfDay(plannedTrip.startDate)\n    const endDate = startOfDay(plannedTrip.endDate)\n    \n    let maxViolation = 0\n    let violationDate: Date | null = null\n    \n    while (currentDate <= endDate) {\n      const daysInWindow = this.calculateDaysInWindow(allTrips, currentDate)\n      const overstay = Math.max(0, daysInWindow - this.MAX_DAYS_IN_PERIOD)\n      \n      if (overstay > maxViolation) {\n        maxViolation = overstay\n        violationDate = new Date(currentDate)\n      }\n      \n      currentDate = addDays(currentDate, 1)\n    }\n    \n    return {\n      isValid: maxViolation === 0,\n      violationDays: maxViolation,\n      violationDate\n    }\n  }\n\n  /**\n   * Find the latest date when a trip of specified length could start without violation\n   */\n  static findLatestValidStartDate(\n    existingTrips: Trip[],\n    tripLength: number,\n    earliestStart: Date,\n    latestStart: Date\n  ): Date | null {\n    let testDate = startOfDay(latestStart)\n    const minDate = startOfDay(earliestStart)\n    \n    while (testDate >= minDate) {\n      const testTrip: Trip = {\n        id: 'test',\n        country: 'TEST',\n        startDate: testDate,\n        endDate: addDays(testDate, tripLength - 1),\n        days: tripLength\n      }\n      \n      const validation = this.validatePlannedTrip(existingTrips, testTrip)\n      if (validation.isValid) {\n        return testDate\n      }\n      \n      testDate = subDays(testDate, 1)\n    }\n    \n    return null\n  }\n\n  /**\n   * Calculate maximum consecutive days available from a start date\n   */\n  static calculateMaxConsecutiveDays(existingTrips: Trip[], startDate: Date): number {\n    let maxDays = 0\n    let testLength = 1\n    const maxTestLength = 100 // Safety limit\n    \n    while (testLength <= maxTestLength) {\n      const testTrip: Trip = {\n        id: 'test',\n        country: 'TEST',\n        startDate: startOfDay(startDate),\n        endDate: addDays(startOfDay(startDate), testLength - 1),\n        days: testLength\n      }\n      \n      const validation = this.validatePlannedTrip(existingTrips, testTrip)\n      if (validation.isValid) {\n        maxDays = testLength\n        testLength++\n      } else {\n        break\n      }\n    }\n    \n    return Math.min(maxDays, this.MAX_DAYS_IN_PERIOD)\n  }\n\n  /**\n   * Comprehensive trip validation\n   */\n  static validateTrips(trips: Trip[]): TripValidationResult {\n    const errors: ValidationError[] = []\n    const warnings: ValidationError[] = []\n    const seenIds = new Set<string>()\n\n    trips.forEach((trip, index) => {\n      // Check for duplicate IDs\n      if (seenIds.has(trip.id)) {\n        errors.push({\n          field: 'id',\n          message: `Duplicate trip ID: ${trip.id}`,\n          severity: 'ERROR',\n          tripId: trip.id\n        })\n      }\n      seenIds.add(trip.id)\n\n      // Required fields\n      if (!trip.id || trip.id.trim() === '') {\n        errors.push({\n          field: 'id',\n          message: `Trip at index ${index} is missing an ID`,\n          severity: 'ERROR'\n        })\n      }\n\n      if (!trip.country || trip.country.trim() === '') {\n        errors.push({\n          field: 'country',\n          message: 'Country is required',\n          severity: 'ERROR',\n          tripId: trip.id\n        })\n      }\n\n      if (!trip.startDate) {\n        errors.push({\n          field: 'startDate',\n          message: 'Start date is required',\n          severity: 'ERROR',\n          tripId: trip.id\n        })\n      }\n\n      if (!trip.endDate) {\n        errors.push({\n          field: 'endDate',\n          message: 'End date is required',\n          severity: 'ERROR',\n          tripId: trip.id\n        })\n      }\n\n      // Date validation\n      if (trip.startDate && trip.endDate) {\n        if (trip.startDate > trip.endDate) {\n          errors.push({\n            field: 'dates',\n            message: 'Start date must be before or equal to end date',\n            severity: 'ERROR',\n            tripId: trip.id\n          })\n        }\n\n        const duration = differenceInDays(trip.endDate, trip.startDate) + 1\n        \n        if (duration > this.MAX_DAYS_IN_PERIOD) {\n          errors.push({\n            field: 'duration',\n            message: `Trip duration (${duration} days) exceeds maximum allowed consecutive stay (${this.MAX_DAYS_IN_PERIOD} days)`,\n            severity: 'ERROR',\n            tripId: trip.id\n          })\n        }\n\n        if (duration < 1) {\n          errors.push({\n            field: 'duration',\n            message: 'Trip must be at least 1 day long',\n            severity: 'ERROR',\n            tripId: trip.id\n          })\n        }\n\n        // Check for unreasonable dates\n        const now = new Date()\n        const tenYearsAgo = subDays(now, 365 * 10)\n        const fiveYearsFromNow = addDays(now, 365 * 5)\n\n        if (trip.startDate < tenYearsAgo) {\n          warnings.push({\n            field: 'startDate',\n            message: 'Start date seems unreasonably far in the past',\n            severity: 'WARNING',\n            tripId: trip.id\n          })\n        }\n\n        if (trip.endDate > fiveYearsFromNow) {\n          warnings.push({\n            field: 'endDate',\n            message: 'End date seems unreasonably far in the future',\n            severity: 'WARNING',\n            tripId: trip.id\n          })\n        }\n\n        // Check for consistency with days field\n        if (trip.days && Math.abs(trip.days - duration) > 0) {\n          warnings.push({\n            field: 'days',\n            message: `Days field (${trip.days}) doesn't match calculated duration (${duration})`,\n            severity: 'WARNING',\n            tripId: trip.id\n          })\n        }\n      }\n    })\n\n    // Check for overlapping trips (same dates)\n    for (let i = 0; i < trips.length; i++) {\n      for (let j = i + 1; j < trips.length; j++) {\n        const trip1 = trips[i]\n        const trip2 = trips[j]\n        \n        if (!trip1.startDate || !trip1.endDate || !trip2.startDate || !trip2.endDate) continue\n\n        // Check if trips overlap\n        const overlap = !(trip1.endDate < trip2.startDate || trip2.endDate < trip1.startDate)\n        \n        if (overlap) {\n          warnings.push({\n            field: 'dates',\n            message: `Trip ${trip1.id} overlaps with trip ${trip2.id}. This may be intentional for same-day travel between countries.`,\n            severity: 'WARNING',\n            tripId: trip1.id\n          })\n        }\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    }\n  }\n\n  /**\n   * Get next date when days will \"roll off\" the window\n   */\n  static getNextResetDate(trips: Trip[], referenceDate: Date = new Date()): Date | null {\n    const normalizedRefDate = startOfDay(referenceDate)\n    const currentWindow = subDays(normalizedRefDate, this.ROLLING_PERIOD_DAYS - 1)\n    \n    // Find the earliest trip day that affects the current window\n    let earliestRelevantDate: Date | null = null\n    \n    for (const trip of trips) {\n      let checkDate = startOfDay(trip.startDate)\n      const endDate = startOfDay(trip.endDate)\n      \n      while (checkDate <= endDate) {\n        if (checkDate >= currentWindow && checkDate <= normalizedRefDate) {\n          if (!earliestRelevantDate || checkDate < earliestRelevantDate) {\n            earliestRelevantDate = checkDate\n          }\n        }\n        checkDate = addDays(checkDate, 1)\n      }\n    }\n    \n    if (!earliestRelevantDate) return null\n    \n    // The reset date is 180 days after the earliest relevant date\n    return addDays(earliestRelevantDate, this.ROLLING_PERIOD_DAYS)\n  }\n\n  /**\n   * Debug function to visualize rolling window calculations\n   */\n  static debugRollingWindow(trips: Trip[], referenceDate: Date): any {\n    const result = this.calculateExactCompliance(trips, referenceDate)\n    \n    return {\n      summary: {\n        totalDaysUsed: result.totalDaysUsed,\n        daysRemaining: result.daysRemaining,\n        isCompliant: result.isCompliant,\n        overstayDays: result.overstayDays,\n        periodStart: result.periodStart,\n        periodEnd: result.periodEnd\n      },\n      tripsInPeriod: trips.filter(trip => \n        trip.endDate >= result.periodStart && trip.startDate <= result.periodEnd\n      ),\n      dailyBreakdown: result.detailedBreakdown.filter(day => day.daysUsedOnDate > 0),\n      violations: result.detailedBreakdown.filter(day => day.isViolation),\n      nextResetDate: this.getNextResetDate(trips, referenceDate)\n    }\n  }\n\n  /**\n   * Validate and normalize trip data with error handling\n   */\n  private static validateAndNormalizeTrips(trips: Trip[]): Trip[] {\n    // Run validation but proceed with filtering\n    const validationResult = this.validateTrips(trips)\n    const criticalErrors = validationResult.errors\n    \n    if (criticalErrors.length > 0) {\n      console.warn('Critical validation errors found:', criticalErrors)\n    }\n\n    return trips\n      .filter(trip => {\n        // Only include trips that pass basic validation\n        if (!trip.startDate || !trip.endDate || !trip.country) return false\n        \n        // Enhanced date validation\n        if (!isValid(trip.startDate) || !isValid(trip.endDate)) {\n          console.warn(`Trip ${trip.id} has invalid dates`)\n          return false\n        }\n        \n        if (trip.startDate > trip.endDate) return false\n        \n        // Filter out trips with excessive duration\n        const duration = differenceInDays(trip.endDate, trip.startDate) + 1\n        if (duration > this.MAX_DAYS_IN_PERIOD) return false\n        \n        // Filter out trips with unreasonable dates\n        const now = new Date()\n        const veryOld = subDays(now, 365 * 20) // 20 years ago\n        const veryFuture = addDays(now, 365 * 10) // 10 years in future\n        \n        if (trip.endDate < veryOld || trip.startDate > veryFuture) {\n          console.warn(`Trip ${trip.id} has unreasonable dates`)\n          return false\n        }\n        \n        return true\n      })\n      .map(trip => {\n        try {\n          const normalizedTrip = {\n            ...trip,\n            startDate: this.normalizeToStartOfDay(trip.startDate),\n            endDate: this.normalizeToStartOfDay(trip.endDate),\n            days: differenceInDays(trip.endDate, trip.startDate) + 1\n          }\n          \n          // Validate normalized dates\n          if (!isValid(normalizedTrip.startDate) || !isValid(normalizedTrip.endDate)) {\n            console.error(`Invalid dates after normalization for trip ${trip.id}`)\n            return null\n          }\n          \n          // Check for leap year edge cases in trip duration\n          const hasLeapDay = this.tripCrossesLeapDay(normalizedTrip.startDate, normalizedTrip.endDate)\n          if (hasLeapDay) {\n            console.debug(`Trip ${trip.id} crosses leap day`)\n          }\n          \n          return normalizedTrip\n        } catch (error) {\n          console.error(`Error normalizing trip ${trip.id}:`, error)\n          return null\n        }\n      })\n      .filter((trip): trip is Trip => trip !== null)\n      .sort((a, b) => a.startDate.getTime() - b.startDate.getTime())\n  }\n\n  /**\n   * Create a map of daily stays for efficient lookup\n   */\n  private static createDailyStayMap(\n    trips: Trip[],\n    periodStart: Date,\n    periodEnd: Date\n  ): Map<string, string[]> {\n    const dailyStays = new Map<string, string[]>()\n    \n    for (const trip of trips) {\n      // Only consider trips that overlap with our period\n      if (trip.endDate < periodStart || trip.startDate > periodEnd) continue\n      \n      // Calculate the actual overlap\n      const overlapStart = trip.startDate > periodStart ? trip.startDate : periodStart\n      const overlapEnd = trip.endDate < periodEnd ? trip.endDate : periodEnd\n      \n      // Add each day of the trip\n      let currentDate = new Date(overlapStart)\n      while (currentDate <= overlapEnd) {\n        const dateKey = currentDate.toISOString().split('T')[0]\n        \n        if (!dailyStays.has(dateKey)) {\n          dailyStays.set(dateKey, [])\n        }\n        dailyStays.get(dateKey)!.push(trip.id)\n        \n        currentDate = addDays(currentDate, 1)\n      }\n    }\n    \n    return dailyStays\n  }\n\n  /**\n   * Calculate rolling compliance check for every day in the period\n   */\n  private static calculateRollingComplianceForAllDays(\n    dailyStays: Map<string, string[]>,\n    periodStart: Date,\n    periodEnd: Date\n  ): RollingWindowCheck[] {\n    const checks: RollingWindowCheck[] = []\n    \n    let currentDate = new Date(periodStart)\n    while (currentDate <= periodEnd) {\n      const windowStart = subDays(currentDate, this.ROLLING_PERIOD_DAYS - 1)\n      const windowEnd = new Date(currentDate)\n      \n      // Count days in this 180-day window\n      let daysInWindow = 0\n      let checkDate = new Date(windowStart)\n      \n      while (checkDate <= windowEnd) {\n        const dateKey = checkDate.toISOString().split('T')[0]\n        if (dailyStays.has(dateKey)) {\n          daysInWindow++\n        }\n        checkDate = addDays(checkDate, 1)\n      }\n      \n      const overstayDays = Math.max(0, daysInWindow - this.MAX_DAYS_IN_PERIOD)\n      \n      checks.push({\n        date: new Date(currentDate),\n        windowStart: new Date(windowStart),\n        windowEnd: new Date(windowEnd),\n        daysInWindow,\n        isCompliant: overstayDays === 0,\n        overstayDays\n      })\n      \n      currentDate = addDays(currentDate, 1)\n    }\n    \n    return checks\n  }\n\n  /**\n   * Generate detailed day-by-day breakdown\n   */\n  private static generateDetailedBreakdown(\n    dailyStays: Map<string, string[]>,\n    rollingChecks: RollingWindowCheck[],\n    periodStart: Date,\n    periodEnd: Date\n  ): DayBreakdown[] {\n    const breakdown: DayBreakdown[] = []\n    \n    let currentDate = new Date(periodStart)\n    let checkIndex = 0\n    \n    while (currentDate <= periodEnd) {\n      const dateKey = currentDate.toISOString().split('T')[0]\n      const staysOnDate = dailyStays.get(dateKey) || []\n      const daysUsedOnDate = staysOnDate.length > 0 ? 1 : 0\n      \n      const rollingCheck = rollingChecks[checkIndex]\n      \n      breakdown.push({\n        date: new Date(currentDate),\n        daysUsedOnDate,\n        cumulativeDaysInWindow: rollingCheck.daysInWindow,\n        isViolation: !rollingCheck.isCompliant,\n        contributingTrips: staysOnDate\n      })\n      \n      currentDate = addDays(currentDate, 1)\n      checkIndex++\n    }\n    \n    return breakdown\n  }\n\n  /**\n   * Enhanced date normalization with timezone-agnostic handling\n   */\n  private static normalizeToStartOfDay(date: Date): Date {\n    // Use startOfDay but ensure we're working with local time consistently\n    const normalized = startOfDay(date)\n    \n    // Additional validation for edge cases\n    if (!isValid(normalized)) {\n      throw new Error(`Failed to normalize date: ${date}`)\n    }\n    \n    return normalized\n  }\n\n  /**\n   * Calculate period start with leap year awareness\n   */\n  private static calculatePeriodStart(referenceDate: Date): Date {\n    // Standard 180-day window calculation\n    const periodStart = subDays(referenceDate, this.ROLLING_PERIOD_DAYS - 1)\n    \n    // Validate the calculated period start\n    if (!isValid(periodStart)) {\n      throw new Error(`Invalid period start calculated from reference date: ${format(referenceDate, 'yyyy-MM-dd')}`)\n    }\n    \n    // Check if we're crossing leap year boundaries and log for awareness\n    const refYear = referenceDate.getFullYear()\n    const startYear = periodStart.getFullYear()\n    \n    if (refYear !== startYear) {\n      const crossesLeapYear = isLeapYear(refYear) || isLeapYear(startYear)\n      if (crossesLeapYear) {\n        console.debug(`180-day window crosses leap year boundary: ${startYear}-${refYear}`)\n      }\n    }\n    \n    return periodStart\n  }\n\n  /**\n   * Check if a trip crosses February 29th in a leap year\n   */\n  private static tripCrossesLeapDay(startDate: Date, endDate: Date): boolean {\n    const startYear = startDate.getFullYear()\n    const endYear = endDate.getFullYear()\n    \n    // Check each year the trip spans\n    for (let year = startYear; year <= endYear; year++) {\n      if (isLeapYear(year)) {\n        const leapDay = new Date(year, 1, 29) // February 29th\n        if (leapDay >= startDate && leapDay <= endDate) {\n          return true\n        }\n      }\n    }\n    \n    return false\n  }\n}","/**\n * Cross-Validation Helper for Cumulative Rolling Calculations\n * \n * CLAUDE.md Compliant: Ensures cumulative calculations maintain\n * 100% accuracy against RobustSchengenCalculator source of truth\n */\n\nimport { RobustSchengenCalculator } from '../calculator/robust-schengen-calculator'\nimport type { Trip, ComplianceResult } from '../types'\n\nexport interface CumulativeValidationResult {\n  isValid: boolean\n  expectedResult: ComplianceResult\n  actualResult?: ComplianceResult\n  errorMessage?: string\n  validationDetails: {\n    rowIndex: number\n    tripsCount: number\n    referenceDate: string\n    totalDaysUsed: number\n    daysRemaining: number\n  }\n}\n\n/**\n * Validates that cumulative calculation matches RobustSchengenCalculator\n * This is the CRITICAL cross-validation function for EU compliance\n */\nexport function validateCumulativeCalculation(\n  chronologicalTrips: Trip[],\n  rowIndex: number,\n  actualResult?: ComplianceResult\n): CumulativeValidationResult {\n  try {\n    // Input validation\n    if (rowIndex < 0 || rowIndex >= chronologicalTrips.length) {\n      return {\n        isValid: false,\n        expectedResult: createFallbackResult(),\n        errorMessage: `Invalid row index: ${rowIndex}. Must be between 0 and ${chronologicalTrips.length - 1}`,\n        validationDetails: {\n          rowIndex,\n          tripsCount: chronologicalTrips.length,\n          referenceDate: 'invalid',\n          totalDaysUsed: 0,\n          daysRemaining: 90\n        }\n      }\n    }\n\n    // Get cumulative trips up to this row (chronologically)\n    const tripsUpToRow = chronologicalTrips.slice(0, rowIndex + 1)\n    const referenceDate = chronologicalTrips[rowIndex].endDate\n\n    // Calculate expected result using RobustSchengenCalculator (source of truth)\n    const expectedResult = RobustSchengenCalculator.calculateExactCompliance(\n      tripsUpToRow,\n      referenceDate\n    )\n\n    const validationDetails = {\n      rowIndex,\n      tripsCount: tripsUpToRow.length,\n      referenceDate: referenceDate.toISOString(),\n      totalDaysUsed: expectedResult.totalDaysUsed,\n      daysRemaining: expectedResult.daysRemaining\n    }\n\n    // If no actual result provided, just return expected (for preview/debug)\n    if (!actualResult) {\n      return {\n        isValid: true,\n        expectedResult,\n        validationDetails\n      }\n    }\n\n    // Cross-validate actual vs expected results\n    const isValid = (\n      actualResult.totalDaysUsed === expectedResult.totalDaysUsed &&\n      actualResult.daysRemaining === expectedResult.daysRemaining &&\n      actualResult.isCompliant === expectedResult.isCompliant &&\n      actualResult.overstayDays === expectedResult.overstayDays\n    )\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        expectedResult,\n        actualResult,\n        errorMessage: `Cumulative calculation mismatch at row ${rowIndex}. Expected: ${expectedResult.totalDaysUsed} used, ${expectedResult.daysRemaining} remaining. Actual: ${actualResult.totalDaysUsed} used, ${actualResult.daysRemaining} remaining.`,\n        validationDetails\n      }\n    }\n\n    return {\n      isValid: true,\n      expectedResult,\n      actualResult,\n      validationDetails\n    }\n\n  } catch (error) {\n    return {\n      isValid: false,\n      expectedResult: createFallbackResult(),\n      errorMessage: `Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      validationDetails: {\n        rowIndex,\n        tripsCount: chronologicalTrips.length,\n        referenceDate: 'error',\n        totalDaysUsed: 0,\n        daysRemaining: 90\n      }\n    }\n  }\n}\n\n/**\n * Validates the entire chronological sequence for consistency\n * Ensures cumulative totals never decrease unexpectedly within same 180-day period\n */\nexport function validateChronologicalSequence(\n  chronologicalTrips: Trip[]\n): { isValid: boolean; errors: string[]; warnings: string[] } {\n  const errors: string[] = []\n  const warnings: string[] = []\n\n  if (chronologicalTrips.length === 0) {\n    return { isValid: true, errors, warnings }\n  }\n\n  let previousResult: ComplianceResult | null = null\n\n  for (let i = 0; i < chronologicalTrips.length; i++) {\n    const validation = validateCumulativeCalculation(chronologicalTrips, i)\n    \n    if (!validation.isValid) {\n      errors.push(`Row ${i}: ${validation.errorMessage}`)\n      continue\n    }\n\n    const currentResult = validation.expectedResult\n\n    // Check for unexpected decreases in cumulative totals\n    if (previousResult && currentResult) {\n      const daysBetweenReferences = Math.abs(\n        previousResult.referenceDate.getTime() - currentResult.referenceDate.getTime()\n      ) / (1000 * 60 * 60 * 24)\n\n      // If within same 180-day period, totals should generally not decrease\n      if (daysBetweenReferences < 180 && currentResult.totalDaysUsed < previousResult.totalDaysUsed) {\n        warnings.push(\n          `Row ${i}: Cumulative total decreased from ${previousResult.totalDaysUsed} to ${currentResult.totalDaysUsed} ` +\n          `within ${Math.round(daysBetweenReferences)} days. This may indicate trips falling outside rolling window.`\n        )\n      }\n    }\n\n    previousResult = currentResult\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  }\n}\n\n/**\n * Mobile-specific validation helper\n * Adds mobile debugging context for CLAUDE.md compliance\n */\nexport function validateMobileCumulativeCalculation(\n  chronologicalTrips: Trip[],\n  rowIndex: number,\n  actualResult?: ComplianceResult\n): CumulativeValidationResult {\n  const validation = validateCumulativeCalculation(chronologicalTrips, rowIndex, actualResult)\n  \n  // Mobile-specific debugging (CLAUDE.md requirement)\n  console.log(`📱 Mobile validation for row ${rowIndex}:`, {\n    isValid: validation.isValid,\n    tripsCount: validation.validationDetails.tripsCount,\n    totalDaysUsed: validation.validationDetails.totalDaysUsed,\n    daysRemaining: validation.validationDetails.daysRemaining,\n    errorMessage: validation.errorMessage || 'No errors'\n  })\n\n  return validation\n}\n\n/**\n * Performance benchmark for cumulative calculations\n * CLAUDE.md requirement: <50ms per calculation\n */\nexport function benchmarkCumulativePerformance(\n  chronologicalTrips: Trip[]\n): { avgTimePerCalculation: number; maxTime: number; isWithinBenchmark: boolean } {\n  if (chronologicalTrips.length === 0) {\n    return { avgTimePerCalculation: 0, maxTime: 0, isWithinBenchmark: true }\n  }\n\n  const times: number[] = []\n\n  chronologicalTrips.forEach((_, index) => {\n    const startTime = performance.now()\n    validateCumulativeCalculation(chronologicalTrips, index)\n    const endTime = performance.now()\n    times.push(endTime - startTime)\n  })\n\n  const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length\n  const maxTime = Math.max(...times)\n\n  return {\n    avgTimePerCalculation: avgTime,\n    maxTime,\n    isWithinBenchmark: avgTime < 50 && maxTime < 100 // <50ms avg, <100ms max\n  }\n}\n\n/**\n * Helper to create fallback compliance result\n */\nfunction createFallbackResult(): ComplianceResult {\n  const now = new Date()\n  return {\n    totalDaysUsed: 0,\n    daysRemaining: 90,\n    isCompliant: true,\n    overstayDays: 0,\n    referenceDate: now,\n    periodStart: new Date(now.getTime() - 179 * 24 * 60 * 60 * 1000),\n    periodEnd: now,\n    detailedBreakdown: []\n  }\n}\n\n/**\n * Export validation functions for use in production code\n * These can be integrated into the UI for real-time validation\n */\nexport {\n  validateCumulativeCalculation as validateCumulative,\n  validateChronologicalSequence as validateSequence,\n  validateMobileCumulativeCalculation as validateMobile,\n  benchmarkCumulativePerformance as benchmarkPerformance\n}","/**\n * Schengen Area Countries Data\n * Complete list of all 27 Schengen countries with flags and metadata\n * Updated as of 2024 - includes all current member states\n */\n\nexport interface SchengenCountry {\n  code: string\n  name: string\n  flag: string\n  joinedSchengen: string\n  isEUMember: boolean\n  capital: string\n  timezone: string\n  currency: string\n}\n\nexport const SCHENGEN_COUNTRIES: SchengenCountry[] = [\n  {\n    code: 'AT',\n    name: 'Austria',\n    flag: '🇦🇹',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Vienna',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'BE',\n    name: 'Belgium',\n    flag: '🇧🇪',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Brussels',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'BG',\n    name: 'Bulgaria',\n    flag: '🇧🇬',\n    joinedSchengen: '2024',\n    isEUMember: true,\n    capital: 'Sofia',\n    timezone: 'EET',\n    currency: 'BGN'\n  },\n  {\n    code: 'HR',\n    name: 'Croatia',\n    flag: '🇭🇷',\n    joinedSchengen: '2023',\n    isEUMember: true,\n    capital: 'Zagreb',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'CZ',\n    name: 'Czech Republic',\n    flag: '🇨🇿',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Prague',\n    timezone: 'CET',\n    currency: 'CZK'\n  },\n  {\n    code: 'DK',\n    name: 'Denmark',\n    flag: '🇩🇰',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Copenhagen',\n    timezone: 'CET',\n    currency: 'DKK'\n  },\n  {\n    code: 'EE',\n    name: 'Estonia',\n    flag: '🇪🇪',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Tallinn',\n    timezone: 'EET',\n    currency: 'EUR'\n  },\n  {\n    code: 'FI',\n    name: 'Finland',\n    flag: '🇫🇮',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Helsinki',\n    timezone: 'EET',\n    currency: 'EUR'\n  },\n  {\n    code: 'FR',\n    name: 'France',\n    flag: '🇫🇷',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Paris',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'DE',\n    name: 'Germany',\n    flag: '🇩🇪',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Berlin',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'GR',\n    name: 'Greece',\n    flag: '🇬🇷',\n    joinedSchengen: '2000',\n    isEUMember: true,\n    capital: 'Athens',\n    timezone: 'EET',\n    currency: 'EUR'\n  },\n  {\n    code: 'HU',\n    name: 'Hungary',\n    flag: '🇭🇺',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Budapest',\n    timezone: 'CET',\n    currency: 'HUF'\n  },\n  {\n    code: 'IS',\n    name: 'Iceland',\n    flag: '🇮🇸',\n    joinedSchengen: '1996',\n    isEUMember: false,\n    capital: 'Reykjavik',\n    timezone: 'GMT',\n    currency: 'ISK'\n  },\n  {\n    code: 'IT',\n    name: 'Italy',\n    flag: '🇮🇹',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Rome',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'LV',\n    name: 'Latvia',\n    flag: '🇱🇻',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Riga',\n    timezone: 'EET',\n    currency: 'EUR'\n  },\n  {\n    code: 'LI',\n    name: 'Liechtenstein',\n    flag: '🇱🇮',\n    joinedSchengen: '2011',\n    isEUMember: false,\n    capital: 'Vaduz',\n    timezone: 'CET',\n    currency: 'CHF'\n  },\n  {\n    code: 'LT',\n    name: 'Lithuania',\n    flag: '🇱🇹',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Vilnius',\n    timezone: 'EET',\n    currency: 'EUR'\n  },\n  {\n    code: 'LU',\n    name: 'Luxembourg',\n    flag: '🇱🇺',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Luxembourg',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'MT',\n    name: 'Malta',\n    flag: '🇲🇹',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Valletta',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'NL',\n    name: 'Netherlands',\n    flag: '🇳🇱',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Amsterdam',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'NO',\n    name: 'Norway',\n    flag: '🇳🇴',\n    joinedSchengen: '1996',\n    isEUMember: false,\n    capital: 'Oslo',\n    timezone: 'CET',\n    currency: 'NOK'\n  },\n  {\n    code: 'PL',\n    name: 'Poland',\n    flag: '🇵🇱',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Warsaw',\n    timezone: 'CET',\n    currency: 'PLN'\n  },\n  {\n    code: 'PT',\n    name: 'Portugal',\n    flag: '🇵🇹',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Lisbon',\n    timezone: 'WET',\n    currency: 'EUR'\n  },\n  {\n    code: 'RO',\n    name: 'Romania',\n    flag: '🇷🇴',\n    joinedSchengen: '2024',\n    isEUMember: true,\n    capital: 'Bucharest',\n    timezone: 'EET',\n    currency: 'RON'\n  },\n  {\n    code: 'SK',\n    name: 'Slovakia',\n    flag: '🇸🇰',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Bratislava',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'SI',\n    name: 'Slovenia',\n    flag: '🇸🇮',\n    joinedSchengen: '2007',\n    isEUMember: true,\n    capital: 'Ljubljana',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'ES',\n    name: 'Spain',\n    flag: '🇪🇸',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Madrid',\n    timezone: 'CET',\n    currency: 'EUR'\n  },\n  {\n    code: 'SE',\n    name: 'Sweden',\n    flag: '🇸🇪',\n    joinedSchengen: '1995',\n    isEUMember: true,\n    capital: 'Stockholm',\n    timezone: 'CET',\n    currency: 'SEK'\n  },\n  {\n    code: 'CH',\n    name: 'Switzerland',\n    flag: '🇨🇭',\n    joinedSchengen: '2008',\n    isEUMember: false,\n    capital: 'Bern',\n    timezone: 'CET',\n    currency: 'CHF'\n  }\n]\n\n// Utility functions for working with countries\nexport const getCountryByCode = (code: string): SchengenCountry | undefined => {\n  return SCHENGEN_COUNTRIES.find(country => country.code === code)\n}\n\nexport const getCountryByName = (name: string): SchengenCountry | undefined => {\n  return SCHENGEN_COUNTRIES.find(country => \n    country.name.toLowerCase() === name.toLowerCase()\n  )\n}\n\nexport const getCountriesForSelect = () => {\n  return SCHENGEN_COUNTRIES.map(country => ({\n    value: country.code,\n    label: `${country.flag} ${country.name}`,\n    country\n  })).sort((a, b) => a.country.name.localeCompare(b.country.name))\n}\n\nexport const getEUMemberCountries = (): SchengenCountry[] => {\n  return SCHENGEN_COUNTRIES.filter(country => country.isEUMember)\n}\n\nexport const getNonEUSchengenCountries = (): SchengenCountry[] => {\n  return SCHENGEN_COUNTRIES.filter(country => !country.isEUMember)\n}\n\n// Export count for validation\nexport const SCHENGEN_COUNTRIES_COUNT = SCHENGEN_COUNTRIES.length","import { isValid, startOfDay, endOfDay, areIntervalsOverlapping, differenceInDays } from \"date-fns\"\nimport type { Trip, ValidationError } from '../types'\n\nexport interface DateRange {\n  start: Date\n  end: Date\n}\n\nexport interface ValidationResult {\n  isValid: boolean\n  conflicts: ConflictDetail[]\n  message: string\n  occupiedDates: Date[]\n}\n\nexport interface ConflictDetail {\n  tripId: string\n  tripCountry: string\n  conflictStart: Date\n  conflictEnd: Date\n  overlapDays: number\n}\n\nexport interface OverlapPreventionConfig {\n  allowSameDayTravel: boolean\n  allowBorderTransitions: boolean\n  strictMode: boolean\n}\n\n/**\n * Date Overlap Validator - Prevents selection of already occupied dates\n * \n * Core Features:\n * 1. Detects date conflicts between new and existing trips\n * 2. Provides visual indicators for occupied dates (grey + strikethrough)\n * 3. Returns specific conflict details for user feedback\n * 4. Handles edge cases: same-day travel, border transitions\n * 5. Mobile-optimized with larger touch targets\n */\nexport class DateOverlapValidator {\n  private config: OverlapPreventionConfig\n\n  constructor(config: Partial<OverlapPreventionConfig> = {}) {\n    this.config = {\n      allowSameDayTravel: true,\n      allowBorderTransitions: true,\n      strictMode: false,\n      ...config\n    }\n  }\n\n  /**\n   * Validate if a date range conflicts with existing trips (alias for validateDateSpan)\n   */\n  validateDateRange(newRange: DateRange, existingTrips: Trip[]): ValidationResult {\n    return this.validateDateSpan(newRange, existingTrips)\n  }\n\n  /**\n   * Validate if a date range conflicts with existing trips\n   */\n  validateDateSpan(newRange: DateRange, existingTrips: Trip[]): ValidationResult {\n    // Input validation\n    if (!this.isValidDateRange(newRange)) {\n      return {\n        isValid: false,\n        conflicts: [],\n        message: 'Invalid date range provided',\n        occupiedDates: []\n      }\n    }\n\n    // Normalize dates to start/end of day for consistent comparison\n    const normalizedNewRange = {\n      start: startOfDay(newRange.start),\n      end: endOfDay(newRange.end)\n    }\n\n    const conflicts: ConflictDetail[] = []\n    const occupiedDates: Date[] = []\n\n    // Check each existing trip for conflicts\n    for (const trip of existingTrips) {\n      if (!this.isValidTrip(trip)) continue\n\n      const tripRange = {\n        start: startOfDay(trip.startDate),\n        end: endOfDay(trip.endDate)\n      }\n\n      // Check for overlap\n      const hasOverlap = this.rangesOverlap(normalizedNewRange, tripRange)\n      \n      if (hasOverlap) {\n        const conflictDetail = this.calculateConflictDetail(\n          normalizedNewRange,\n          tripRange,\n          trip\n        )\n\n        // Apply configuration rules\n        if (this.shouldReportConflict(conflictDetail, normalizedNewRange, tripRange)) {\n          conflicts.push(conflictDetail)\n        }\n\n        // Add occupied dates for visual indicators\n        this.addOccupiedDatesFromTrip(trip, occupiedDates)\n      }\n    }\n\n    // Get all occupied dates for calendar marking (regardless of conflicts)\n    const allOccupiedDates = this.getAllOccupiedDates(existingTrips)\n\n    return {\n      isValid: conflicts.length === 0,\n      conflicts,\n      message: this.generateValidationMessage(conflicts),\n      occupiedDates: allOccupiedDates\n    }\n  }\n\n  /**\n   * Get all occupied dates from existing trips for calendar display\n   */\n  getAllOccupiedDates(trips: Trip[]): Date[] {\n    const occupiedDates: Date[] = []\n\n    for (const trip of trips) {\n      if (!this.isValidTrip(trip)) continue\n      this.addOccupiedDatesFromTrip(trip, occupiedDates)\n    }\n\n    // Remove duplicates and sort\n    return [...new Set(occupiedDates.map(d => d.getTime()))]\n      .map(time => new Date(time))\n      .sort((a, b) => a.getTime() - b.getTime())\n  }\n\n  /**\n   * Check if a specific date is occupied by existing trips\n   */\n  isDateOccupied(date: Date, existingTrips: Trip[]): boolean {\n    const normalizedDate = startOfDay(date)\n    \n    return existingTrips.some(trip => {\n      if (!this.isValidTrip(trip)) return false\n      \n      const tripStart = startOfDay(trip.startDate)\n      const tripEnd = startOfDay(trip.endDate)\n      \n      return normalizedDate >= tripStart && normalizedDate <= tripEnd\n    })\n  }\n\n  /**\n   * Get trips that occupy a specific date\n   */\n  getTripsOnDate(date: Date, existingTrips: Trip[]): Trip[] {\n    const normalizedDate = startOfDay(date)\n    \n    return existingTrips.filter(trip => {\n      if (!this.isValidTrip(trip)) return false\n      \n      const tripStart = startOfDay(trip.startDate)\n      const tripEnd = startOfDay(trip.endDate)\n      \n      return normalizedDate >= tripStart && normalizedDate <= tripEnd\n    })\n  }\n\n  /**\n   * Find next available date range of specified length\n   */\n  findNextAvailableDateSpan(\n    preferredStart: Date,\n    lengthInDays: number,\n    existingTrips: Trip[],\n    searchLimit: number = 365\n  ): DateRange | null {\n    let testDate = startOfDay(preferredStart)\n    const maxSearchDate = new Date(testDate.getTime() + (searchLimit * 24 * 60 * 60 * 1000))\n\n    while (testDate <= maxSearchDate) {\n      const testRange: DateRange = {\n        start: testDate,\n        end: new Date(testDate.getTime() + ((lengthInDays - 1) * 24 * 60 * 60 * 1000))\n      }\n\n      const validation = this.validateDateSpan(testRange, existingTrips)\n      if (validation.isValid) {\n        return testRange\n      }\n\n      // Move to next day\n      testDate = new Date(testDate.getTime() + (24 * 60 * 60 * 1000))\n    }\n\n    return null\n  }\n\n  /**\n   * Suggest alternative dates when conflicts exist\n   */\n  suggestAlternativeDates(\n    conflictedRange: DateRange,\n    lengthInDays: number,\n    existingTrips: Trip[]\n  ): DateRange[] {\n    const suggestions: DateRange[] = []\n    const duration = lengthInDays || differenceInDays(conflictedRange.end, conflictedRange.start) + 1\n\n    // Try earlier dates\n    const earlierDate = new Date(conflictedRange.start.getTime() - (30 * 24 * 60 * 60 * 1000))\n    const earlierRange = this.findNextAvailableDateSpan(earlierDate, duration, existingTrips, 60)\n    if (earlierRange && earlierRange.start < conflictedRange.start) {\n      suggestions.push(earlierRange)\n    }\n\n    // Try later dates\n    const laterDate = new Date(conflictedRange.end.getTime() + (24 * 60 * 60 * 1000))\n    const laterRange = this.findNextAvailableDateSpan(laterDate, duration, existingTrips, 60)\n    if (laterRange) {\n      suggestions.push(laterRange)\n    }\n\n    return suggestions.slice(0, 3) // Return max 3 suggestions\n  }\n\n  /**\n   * Batch validation for multiple date ranges\n   */\n  validateMultipleDateSpans(\n    newRanges: DateRange[],\n    existingTrips: Trip[]\n  ): { [index: number]: ValidationResult } {\n    const results: { [index: number]: ValidationResult } = {}\n\n    // Create a combined list of existing trips plus validated new trips\n    let combinedTrips = [...existingTrips]\n\n    newRanges.forEach((range, index) => {\n      // Validate against existing trips and previously validated new trips\n      const result = this.validateDateSpan(range, combinedTrips)\n      results[index] = result\n\n      // If valid, add to combined trips for next validations\n      if (result.isValid) {\n        combinedTrips.push({\n          id: `temp-${index}`,\n          country: 'TEMP',\n          startDate: range.start,\n          endDate: range.end,\n          days: differenceInDays(range.end, range.start) + 1\n        })\n      }\n    })\n\n    return results\n  }\n\n  /**\n   * Private: Check if two date ranges overlap\n   */\n  private rangesOverlap(range1: DateRange, range2: DateRange): boolean {\n    return areIntervalsOverlapping(\n      { start: range1.start, end: range1.end },\n      { start: range2.start, end: range2.end }\n    )\n  }\n\n  /**\n   * Private: Calculate detailed conflict information\n   */\n  private calculateConflictDetail(\n    newRange: DateRange,\n    tripRange: DateRange,\n    trip: Trip\n  ): ConflictDetail {\n    // Calculate the actual overlap period\n    const conflictStart = newRange.start > tripRange.start ? newRange.start : tripRange.start\n    const conflictEnd = newRange.end < tripRange.end ? newRange.end : tripRange.end\n    const overlapDays = differenceInDays(conflictEnd, conflictStart) + 1\n\n    return {\n      tripId: trip.id,\n      tripCountry: trip.country,\n      conflictStart,\n      conflictEnd,\n      overlapDays: Math.max(0, overlapDays)\n    }\n  }\n\n  /**\n   * Private: Determine if conflict should be reported based on configuration\n   */\n  private shouldReportConflict(\n    conflict: ConflictDetail,\n    newRange: DateRange,\n    tripRange: DateRange\n  ): boolean {\n    // In strict mode, report all conflicts\n    if (this.config.strictMode) return true\n\n    // Same-day travel exception\n    if (this.config.allowSameDayTravel) {\n      const isSameDayTransition = \n        (newRange.start.getTime() === tripRange.end.getTime()) ||\n        (newRange.end.getTime() === tripRange.start.getTime())\n      \n      if (isSameDayTransition) return false\n    }\n\n    // Border transition exception\n    if (this.config.allowBorderTransitions && conflict.overlapDays <= 1) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Private: Add occupied dates from a trip to the occupied dates array\n   */\n  private addOccupiedDatesFromTrip(trip: Trip, occupiedDates: Date[]): void {\n    const start = startOfDay(trip.startDate)\n    const end = startOfDay(trip.endDate)\n    \n    let currentDate = new Date(start)\n    while (currentDate <= end) {\n      occupiedDates.push(new Date(currentDate))\n      currentDate = new Date(currentDate.getTime() + (24 * 60 * 60 * 1000))\n    }\n  }\n\n  /**\n   * Private: Generate human-readable validation message\n   */\n  private generateValidationMessage(conflicts: ConflictDetail[]): string {\n    if (conflicts.length === 0) {\n      return 'Dates are available'\n    }\n\n    if (conflicts.length === 1) {\n      const conflict = conflicts[0]\n      return `Dates overlap with existing trip to ${conflict.tripCountry} (${conflict.overlapDays} day${conflict.overlapDays !== 1 ? 's' : ''})`\n    }\n\n    return `Dates conflict with ${conflicts.length} existing trips`\n  }\n\n  /**\n   * Private: Validate date range input\n   */\n  private isValidDateRange(range: DateRange): boolean {\n    if (!range || !range.start || !range.end) return false\n    if (!isValid(range.start) || !isValid(range.end)) return false\n    if (range.start > range.end) return false\n    return true\n  }\n\n  /**\n   * Private: Validate trip data\n   */\n  private isValidTrip(trip: Trip): boolean {\n    if (!trip || !trip.startDate || !trip.endDate) return false\n    if (!isValid(trip.startDate) || !isValid(trip.endDate)) return false\n    if (trip.startDate > trip.endDate) return false\n    return true\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<OverlapPreventionConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): OverlapPreventionConfig {\n    return { ...this.config }\n  }\n\n  /**\n   * Find the next available date range starting from a preferred date\n   */\n  findNextAvailableDateRange(\n    preferredStart: Date,\n    lengthInDays: number,\n    existingTrips: Trip[],\n    searchLimitDays: number = 365\n  ): DateRange | null {\n    const searchLimit = new Date(preferredStart.getTime() + searchLimitDays * 24 * 60 * 60 * 1000)\n    \n    for (let searchDate = new Date(preferredStart); searchDate <= searchLimit; searchDate.setDate(searchDate.getDate() + 1)) {\n      const proposedRange: DateRange = {\n        start: new Date(searchDate),\n        end: new Date(searchDate.getTime() + (lengthInDays - 1) * 24 * 60 * 60 * 1000)\n      }\n      \n      const validation = this.validateDateRange(proposedRange, existingTrips)\n      if (validation.isValid) {\n        return proposedRange\n      }\n    }\n    \n    return null\n  }\n\n  /**\n   * Validate multiple date ranges at once\n   */\n  validateMultipleDateRanges(\n    dateRanges: DateRange[],\n    existingTrips: Trip[]\n  ): { [index: number]: ValidationResult } {\n    const results: { [index: number]: ValidationResult } = {}\n    const allProposedTrips: Trip[] = [...existingTrips]\n    \n    dateRanges.forEach((range, index) => {\n      const validation = this.validateDateRange(range, allProposedTrips)\n      results[index] = validation\n      \n      // If this range is valid, add it to the list for subsequent validations\n      if (validation.isValid) {\n        allProposedTrips.push({\n          id: `temp-${index}`,\n          country: `temp-${index}`,\n          startDate: range.start,\n          endDate: range.end,\n          days: Math.ceil((range.end.getTime() - range.start.getTime()) / (1000 * 60 * 60 * 24)) + 1\n        })\n      }\n    })\n    \n    return results\n  }\n}"],"names":["RobustSchengenCalculator","calculateExactCompliance","trips","referenceDate","Date","Array","isArray","Error","isValid","now","tenYearsAgo","subDays","fiveYearsFromNow","addDays","console","warn","format","normalizedRefDate","this","normalizeToStartOfDay","periodStart","calculatePeriodStart","validTrips","validateAndNormalizeTrips","length","totalDaysUsed","daysRemaining","MAX_DAYS_IN_PERIOD","isCompliant","overstayDays","periodEnd","detailedBreakdown","dailyStays","createDailyStayMap","rollingChecks","calculateRollingComplianceForAllDays","maxViolation","Math","max","map","check","currentCompliance","generateDetailedBreakdown","result","daysInWindow","error","startOfDay","ROLLING_PERIOD_DAYS","calculateDaysInWindow","endDate","normalizedEndDate","windowStart","totalDays","trip","startDate","id","tripStart","tripEnd","overlapStart","overlapEnd","daysInOverlap","differenceInDays","validatePlannedTrip","existingTrips","plannedTrip","allTrips","currentDate","violationDate","overstay","violationDays","findLatestValidStartDate","tripLength","earliestStart","latestStart","testDate","minDate","testTrip","country","days","calculateMaxConsecutiveDays","maxDays","testLength","min","validateTrips","errors","warnings","seenIds","Set","forEach","index","has","push","field","message","severity","tripId","add","trim","duration","abs","i","j","trip1","trip2","getNextResetDate","currentWindow","earliestRelevantDate","checkDate","debugRollingWindow","summary","tripsInPeriod","filter","dailyBreakdown","day","daysUsedOnDate","violations","isViolation","nextResetDate","criticalErrors","veryOld","veryFuture","normalizedTrip","tripCrossesLeapDay","debug","sort","a","b","getTime","Map","dateKey","toISOString","split","set","get","checks","windowEnd","date","breakdown","checkIndex","staysOnDate","rollingCheck","cumulativeDaysInWindow","contributingTrips","normalized","refYear","getFullYear","startYear","isLeapYear","endYear","year","leapDay","validateCumulativeCalculation","chronologicalTrips","rowIndex","actualResult","expectedResult","createFallbackResult","errorMessage","validationDetails","tripsCount","tripsUpToRow","slice","SCHENGEN_COUNTRIES","code","name","flag","joinedSchengen","isEUMember","capital","timezone","currency","SCHENGEN_COUNTRIES_COUNT","validateDateRange","newRange","validateDateSpan","isValidDateRange","conflicts","occupiedDates","normalizedNewRange","start","end","endOfDay","isValidTrip","tripRange","rangesOverlap","conflictDetail","calculateConflictDetail","shouldReportConflict","addOccupiedDatesFromTrip","allOccupiedDates","getAllOccupiedDates","generateValidationMessage","d","time","isDateOccupied","normalizedDate","some","getTripsOnDate","findNextAvailableDateSpan","preferredStart","lengthInDays","searchLimit","maxSearchDate","testRange","suggestAlternativeDates","conflictedRange","suggestions","earlierDate","earlierRange","laterDate","laterRange","validateMultipleDateSpans","newRanges","results","combinedTrips","range","range1","range2","areIntervalsOverlapping","conflictStart","conflictEnd","overlapDays","tripCountry","conflict","config","strictMode","allowSameDayTravel","allowBorderTransitions","updateConfig","newConfig","getConfig","findNextAvailableDateRange","searchLimitDays","searchDate","setDate","getDate","proposedRange","validateMultipleDateRanges","dateRanges","allProposedTrips","validation","ceil","constructor","avgTimePerCalculation","maxTime","isWithinBenchmark","times","_","startTime","performance","endTime","avgTime","reduce","sum","value","label","localeCompare","find","toLowerCase","log","previousResult","currentResult","daysBetweenReferences","round"],"mappings":"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"}