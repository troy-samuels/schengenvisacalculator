!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("date-fns")):"function"==typeof define&&define.amd?define(["exports","date-fns"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).SchengenCalculator={},e.dateFns)}(this,function(e,t){"use strict";class a{static calculateExactCompliance(e,a=new Date){try{if(!Array.isArray(e))throw new Error("Trips must be an array");if(!a||!t.isValid(a))throw new Error("Reference date must be a valid Date object");const n=new Date,i=t.subDays(n,3650),r=t.addDays(n,1825);(a<i||a>r)&&console.warn(`Reference date ${t.format(a,"yyyy-MM-dd")} is outside reasonable range`);const s=this.normalizeToStartOfDay(a),o=this.calculatePeriodStart(s),d=this.validateAndNormalizeTrips(e);if(0===d.length)return{totalDaysUsed:0,daysRemaining:this.MAX_DAYS_IN_PERIOD,isCompliant:!0,overstayDays:0,referenceDate:s,periodStart:o,periodEnd:s,detailedBreakdown:[]};const l=this.createDailyStayMap(d,o,s),c=this.calculateRollingComplianceForAllDays(l,o,s);if(0===c.length)throw new Error("Failed to generate rolling compliance checks");const D=Math.max(...c.map(e=>e.overstayDays)),u=c[c.length-1];if(!u)throw new Error("Failed to get current compliance status");const f=this.generateDetailedBreakdown(l,c,o,s),y={totalDaysUsed:u.daysInWindow,daysRemaining:Math.max(0,this.MAX_DAYS_IN_PERIOD-u.daysInWindow),isCompliant:0===D,overstayDays:D,referenceDate:s,periodStart:o,periodEnd:s,detailedBreakdown:f};if(y.totalDaysUsed<0||y.daysRemaining<0)throw console.error("Invalid calculation result:",y),new Error("Calculation produced invalid negative values");return y}catch(e){console.error("Error in calculateExactCompliance:",e);const n=t.startOfDay(a);return{totalDaysUsed:0,daysRemaining:this.MAX_DAYS_IN_PERIOD,isCompliant:!0,overstayDays:0,referenceDate:n,periodStart:t.subDays(n,this.ROLLING_PERIOD_DAYS-1),periodEnd:n,detailedBreakdown:[]}}}static calculateDaysInWindow(e,a){if(!t.isValid(a))throw new Error("End date must be valid");const n=this.normalizeToStartOfDay(a),i=this.calculatePeriodStart(n);let r=0;for(const a of e){if(!t.isValid(a.startDate)||!t.isValid(a.endDate)){console.warn(`Skipping trip ${a.id} with invalid dates`);continue}const e=this.normalizeToStartOfDay(a.startDate),s=this.normalizeToStartOfDay(a.endDate),o=e>i?e:i,d=s<n?s:n;if(o<=d){const e=t.differenceInDays(d,o)+1;if(e<0){console.error(`Negative days calculated for trip ${a.id}`);continue}r+=e}}return r}static validatePlannedTrip(e,a){const n=[...e,a];let i=t.startOfDay(a.startDate);const r=t.startOfDay(a.endDate);let s=0,o=null;for(;i<=r;){const e=this.calculateDaysInWindow(n,i),a=Math.max(0,e-this.MAX_DAYS_IN_PERIOD);a>s&&(s=a,o=new Date(i)),i=t.addDays(i,1)}return{isValid:0===s,violationDays:s,violationDate:o}}static findLatestValidStartDate(e,a,n,i){let r=t.startOfDay(i);const s=t.startOfDay(n);for(;r>=s;){const n={id:"test",country:"TEST",startDate:r,endDate:t.addDays(r,a-1),days:a};if(this.validatePlannedTrip(e,n).isValid)return r;r=t.subDays(r,1)}return null}static calculateMaxConsecutiveDays(e,a){let n=0,i=1;for(;i<=100;){const r={id:"test",country:"TEST",startDate:t.startOfDay(a),endDate:t.addDays(t.startOfDay(a),i-1),days:i};if(!this.validatePlannedTrip(e,r).isValid)break;n=i,i++}return Math.min(n,this.MAX_DAYS_IN_PERIOD)}static validateTrips(e){const a=[],n=[],i=new Set;e.forEach((e,r)=>{if(i.has(e.id)&&a.push({field:"id",message:`Duplicate trip ID: ${e.id}`,severity:"ERROR",tripId:e.id}),i.add(e.id),e.id&&""!==e.id.trim()||a.push({field:"id",message:`Trip at index ${r} is missing an ID`,severity:"ERROR"}),e.country&&""!==e.country.trim()||a.push({field:"country",message:"Country is required",severity:"ERROR",tripId:e.id}),e.startDate||a.push({field:"startDate",message:"Start date is required",severity:"ERROR",tripId:e.id}),e.endDate||a.push({field:"endDate",message:"End date is required",severity:"ERROR",tripId:e.id}),e.startDate&&e.endDate){e.startDate>e.endDate&&a.push({field:"dates",message:"Start date must be before or equal to end date",severity:"ERROR",tripId:e.id});const i=t.differenceInDays(e.endDate,e.startDate)+1;i>this.MAX_DAYS_IN_PERIOD&&a.push({field:"duration",message:`Trip duration (${i} days) exceeds maximum allowed consecutive stay (${this.MAX_DAYS_IN_PERIOD} days)`,severity:"ERROR",tripId:e.id}),i<1&&a.push({field:"duration",message:"Trip must be at least 1 day long",severity:"ERROR",tripId:e.id});const r=new Date,s=t.subDays(r,3650),o=t.addDays(r,1825);e.startDate<s&&n.push({field:"startDate",message:"Start date seems unreasonably far in the past",severity:"WARNING",tripId:e.id}),e.endDate>o&&n.push({field:"endDate",message:"End date seems unreasonably far in the future",severity:"WARNING",tripId:e.id}),e.days&&Math.abs(e.days-i)>0&&n.push({field:"days",message:`Days field (${e.days}) doesn't match calculated duration (${i})`,severity:"WARNING",tripId:e.id})}});for(let t=0;t<e.length;t++)for(let a=t+1;a<e.length;a++){const i=e[t],r=e[a];if(!(i.startDate&&i.endDate&&r.startDate&&r.endDate))continue;!(i.endDate<r.startDate||r.endDate<i.startDate)&&n.push({field:"dates",message:`Trip ${i.id} overlaps with trip ${r.id}. This may be intentional for same-day travel between countries.`,severity:"WARNING",tripId:i.id})}return{isValid:0===a.length,errors:a,warnings:n}}static getNextResetDate(e,a=new Date){const n=t.startOfDay(a),i=t.subDays(n,this.ROLLING_PERIOD_DAYS-1);let r=null;for(const a of e){let e=t.startOfDay(a.startDate);const s=t.startOfDay(a.endDate);for(;e<=s;)e>=i&&e<=n&&(!r||e<r)&&(r=e),e=t.addDays(e,1)}return r?t.addDays(r,this.ROLLING_PERIOD_DAYS):null}static debugRollingWindow(e,t){const a=this.calculateExactCompliance(e,t);return{summary:{totalDaysUsed:a.totalDaysUsed,daysRemaining:a.daysRemaining,isCompliant:a.isCompliant,overstayDays:a.overstayDays,periodStart:a.periodStart,periodEnd:a.periodEnd},tripsInPeriod:e.filter(e=>e.endDate>=a.periodStart&&e.startDate<=a.periodEnd),dailyBreakdown:a.detailedBreakdown.filter(e=>e.daysUsedOnDate>0),violations:a.detailedBreakdown.filter(e=>e.isViolation),nextResetDate:this.getNextResetDate(e,t)}}static validateAndNormalizeTrips(e){const a=this.validateTrips(e).errors;return a.length>0&&console.warn("Critical validation errors found:",a),e.filter(e=>{if(!e.startDate||!e.endDate||!e.country)return!1;if(!t.isValid(e.startDate)||!t.isValid(e.endDate))return console.warn(`Trip ${e.id} has invalid dates`),!1;if(e.startDate>e.endDate)return!1;if(t.differenceInDays(e.endDate,e.startDate)+1>this.MAX_DAYS_IN_PERIOD)return!1;const a=new Date,n=t.subDays(a,7300),i=t.addDays(a,3650);return!(e.endDate<n||e.startDate>i)||(console.warn(`Trip ${e.id} has unreasonable dates`),!1)}).map(e=>{try{const a={...e,startDate:this.normalizeToStartOfDay(e.startDate),endDate:this.normalizeToStartOfDay(e.endDate),days:t.differenceInDays(e.endDate,e.startDate)+1};if(!t.isValid(a.startDate)||!t.isValid(a.endDate))return console.error(`Invalid dates after normalization for trip ${e.id}`),null;return this.tripCrossesLeapDay(a.startDate,a.endDate)&&console.debug(`Trip ${e.id} crosses leap day`),a}catch(t){return console.error(`Error normalizing trip ${e.id}:`,t),null}}).filter(e=>null!==e).sort((e,t)=>e.startDate.getTime()-t.startDate.getTime())}static createDailyStayMap(e,a,n){const i=new Map;for(const r of e){if(r.endDate<a||r.startDate>n)continue;const e=r.startDate>a?r.startDate:a,s=r.endDate<n?r.endDate:n;let o=new Date(e);for(;o<=s;){const e=o.toISOString().split("T")[0];i.has(e)||i.set(e,[]),i.get(e).push(r.id),o=t.addDays(o,1)}}return i}static calculateRollingComplianceForAllDays(e,a,n){const i=[];let r=new Date(a);for(;r<=n;){const a=t.subDays(r,this.ROLLING_PERIOD_DAYS-1),n=new Date(r);let s=0,o=new Date(a);for(;o<=n;){const a=o.toISOString().split("T")[0];e.has(a)&&s++,o=t.addDays(o,1)}const d=Math.max(0,s-this.MAX_DAYS_IN_PERIOD);i.push({date:new Date(r),windowStart:new Date(a),windowEnd:new Date(n),daysInWindow:s,isCompliant:0===d,overstayDays:d}),r=t.addDays(r,1)}return i}static generateDetailedBreakdown(e,a,n,i){const r=[];let s=new Date(n),o=0;for(;s<=i;){const n=s.toISOString().split("T")[0],i=e.get(n)||[],d=i.length>0?1:0,l=a[o];r.push({date:new Date(s),daysUsedOnDate:d,cumulativeDaysInWindow:l.daysInWindow,isViolation:!l.isCompliant,contributingTrips:i}),s=t.addDays(s,1),o++}return r}static normalizeToStartOfDay(e){const a=t.startOfDay(e);if(!t.isValid(a))throw new Error(`Failed to normalize date: ${e}`);return a}static calculatePeriodStart(e){const a=t.subDays(e,this.ROLLING_PERIOD_DAYS-1);if(!t.isValid(a))throw new Error(`Invalid period start calculated from reference date: ${t.format(e,"yyyy-MM-dd")}`);const n=e.getFullYear(),i=a.getFullYear();if(n!==i){(t.isLeapYear(n)||t.isLeapYear(i))&&console.debug(`180-day window crosses leap year boundary: ${i}-${n}`)}return a}static tripCrossesLeapDay(e,a){const n=e.getFullYear(),i=a.getFullYear();for(let r=n;r<=i;r++)if(t.isLeapYear(r)){const t=new Date(r,1,29);if(t>=e&&t<=a)return!0}return!1}}a.MAX_DAYS_IN_PERIOD=90,a.ROLLING_PERIOD_DAYS=180;const n=[{code:"AT",name:"Austria",flag:"ðŸ‡¦ðŸ‡¹",joinedSchengen:"1995",isEUMember:!0,capital:"Vienna",timezone:"CET",currency:"EUR"},{code:"BE",name:"Belgium",flag:"ðŸ‡§ðŸ‡ª",joinedSchengen:"1995",isEUMember:!0,capital:"Brussels",timezone:"CET",currency:"EUR"},{code:"BG",name:"Bulgaria",flag:"ðŸ‡§ðŸ‡¬",joinedSchengen:"2024",isEUMember:!0,capital:"Sofia",timezone:"EET",currency:"BGN"},{code:"HR",name:"Croatia",flag:"ðŸ‡­ðŸ‡·",joinedSchengen:"2023",isEUMember:!0,capital:"Zagreb",timezone:"CET",currency:"EUR"},{code:"CZ",name:"Czech Republic",flag:"ðŸ‡¨ðŸ‡¿",joinedSchengen:"2007",isEUMember:!0,capital:"Prague",timezone:"CET",currency:"CZK"},{code:"DK",name:"Denmark",flag:"ðŸ‡©ðŸ‡°",joinedSchengen:"1995",isEUMember:!0,capital:"Copenhagen",timezone:"CET",currency:"DKK"},{code:"EE",name:"Estonia",flag:"ðŸ‡ªðŸ‡ª",joinedSchengen:"2007",isEUMember:!0,capital:"Tallinn",timezone:"EET",currency:"EUR"},{code:"FI",name:"Finland",flag:"ðŸ‡«ðŸ‡®",joinedSchengen:"1995",isEUMember:!0,capital:"Helsinki",timezone:"EET",currency:"EUR"},{code:"FR",name:"France",flag:"ðŸ‡«ðŸ‡·",joinedSchengen:"1995",isEUMember:!0,capital:"Paris",timezone:"CET",currency:"EUR"},{code:"DE",name:"Germany",flag:"ðŸ‡©ðŸ‡ª",joinedSchengen:"1995",isEUMember:!0,capital:"Berlin",timezone:"CET",currency:"EUR"},{code:"GR",name:"Greece",flag:"ðŸ‡¬ðŸ‡·",joinedSchengen:"2000",isEUMember:!0,capital:"Athens",timezone:"EET",currency:"EUR"},{code:"HU",name:"Hungary",flag:"ðŸ‡­ðŸ‡º",joinedSchengen:"2007",isEUMember:!0,capital:"Budapest",timezone:"CET",currency:"HUF"},{code:"IS",name:"Iceland",flag:"ðŸ‡®ðŸ‡¸",joinedSchengen:"1996",isEUMember:!1,capital:"Reykjavik",timezone:"GMT",currency:"ISK"},{code:"IT",name:"Italy",flag:"ðŸ‡®ðŸ‡¹",joinedSchengen:"1995",isEUMember:!0,capital:"Rome",timezone:"CET",currency:"EUR"},{code:"LV",name:"Latvia",flag:"ðŸ‡±ðŸ‡»",joinedSchengen:"2007",isEUMember:!0,capital:"Riga",timezone:"EET",currency:"EUR"},{code:"LI",name:"Liechtenstein",flag:"ðŸ‡±ðŸ‡®",joinedSchengen:"2011",isEUMember:!1,capital:"Vaduz",timezone:"CET",currency:"CHF"},{code:"LT",name:"Lithuania",flag:"ðŸ‡±ðŸ‡¹",joinedSchengen:"2007",isEUMember:!0,capital:"Vilnius",timezone:"EET",currency:"EUR"},{code:"LU",name:"Luxembourg",flag:"ðŸ‡±ðŸ‡º",joinedSchengen:"1995",isEUMember:!0,capital:"Luxembourg",timezone:"CET",currency:"EUR"},{code:"MT",name:"Malta",flag:"ðŸ‡²ðŸ‡¹",joinedSchengen:"2007",isEUMember:!0,capital:"Valletta",timezone:"CET",currency:"EUR"},{code:"NL",name:"Netherlands",flag:"ðŸ‡³ðŸ‡±",joinedSchengen:"1995",isEUMember:!0,capital:"Amsterdam",timezone:"CET",currency:"EUR"},{code:"NO",name:"Norway",flag:"ðŸ‡³ðŸ‡´",joinedSchengen:"1996",isEUMember:!1,capital:"Oslo",timezone:"CET",currency:"NOK"},{code:"PL",name:"Poland",flag:"ðŸ‡µðŸ‡±",joinedSchengen:"2007",isEUMember:!0,capital:"Warsaw",timezone:"CET",currency:"PLN"},{code:"PT",name:"Portugal",flag:"ðŸ‡µðŸ‡¹",joinedSchengen:"1995",isEUMember:!0,capital:"Lisbon",timezone:"WET",currency:"EUR"},{code:"RO",name:"Romania",flag:"ðŸ‡·ðŸ‡´",joinedSchengen:"2024",isEUMember:!0,capital:"Bucharest",timezone:"EET",currency:"RON"},{code:"SK",name:"Slovakia",flag:"ðŸ‡¸ðŸ‡°",joinedSchengen:"2007",isEUMember:!0,capital:"Bratislava",timezone:"CET",currency:"EUR"},{code:"SI",name:"Slovenia",flag:"ðŸ‡¸ðŸ‡®",joinedSchengen:"2007",isEUMember:!0,capital:"Ljubljana",timezone:"CET",currency:"EUR"},{code:"ES",name:"Spain",flag:"ðŸ‡ªðŸ‡¸",joinedSchengen:"1995",isEUMember:!0,capital:"Madrid",timezone:"CET",currency:"EUR"},{code:"SE",name:"Sweden",flag:"ðŸ‡¸ðŸ‡ª",joinedSchengen:"1995",isEUMember:!0,capital:"Stockholm",timezone:"CET",currency:"SEK"},{code:"CH",name:"Switzerland",flag:"ðŸ‡¨ðŸ‡­",joinedSchengen:"2008",isEUMember:!1,capital:"Bern",timezone:"CET",currency:"CHF"}],i=n.length;e.DateOverlapValidator=class{validateDateSpan(e,a){if(!this.isValidDateRange(e))return{isValid:!1,conflicts:[],message:"Invalid date range provided",occupiedDates:[]};const n={start:t.startOfDay(e.start),end:t.endOfDay(e.end)},i=[],r=[];for(const e of a){if(!this.isValidTrip(e))continue;const a={start:t.startOfDay(e.startDate),end:t.endOfDay(e.endDate)};if(this.rangesOverlap(n,a)){const t=this.calculateConflictDetail(n,a,e);this.shouldReportConflict(t,n,a)&&i.push(t),this.addOccupiedDatesFromTrip(e,r)}}const s=this.getAllOccupiedDates(a);return{isValid:0===i.length,conflicts:i,message:this.generateValidationMessage(i),occupiedDates:s}}getAllOccupiedDates(e){const t=[];for(const a of e)this.isValidTrip(a)&&this.addOccupiedDatesFromTrip(a,t);return[...new Set(t.map(e=>e.getTime()))].map(e=>new Date(e)).sort((e,t)=>e.getTime()-t.getTime())}isDateOccupied(e,a){const n=t.startOfDay(e);return a.some(e=>{if(!this.isValidTrip(e))return!1;const a=t.startOfDay(e.startDate),i=t.startOfDay(e.endDate);return n>=a&&n<=i})}getTripsOnDate(e,a){const n=t.startOfDay(e);return a.filter(e=>{if(!this.isValidTrip(e))return!1;const a=t.startOfDay(e.startDate),i=t.startOfDay(e.endDate);return n>=a&&n<=i})}findNextAvailableDateSpan(e,a,n,i=365){let r=t.startOfDay(e);const s=new Date(r.getTime()+24*i*60*60*1e3);for(;r<=s;){const e={start:r,end:new Date(r.getTime()+24*(a-1)*60*60*1e3)};if(this.validateDateSpan(e,n).isValid)return e;r=new Date(r.getTime()+864e5)}return null}suggestAlternativeDates(e,a,n){const i=[],r=a||t.differenceInDays(e.end,e.start)+1,s=new Date(e.start.getTime()-2592e6),o=this.findNextAvailableDateSpan(s,r,n,60);o&&o.start<e.start&&i.push(o);const d=new Date(e.end.getTime()+864e5),l=this.findNextAvailableDateSpan(d,r,n,60);return l&&i.push(l),i.slice(0,3)}validateMultipleDateSpans(e,a){const n={};let i=[...a];return e.forEach((e,a)=>{const r=this.validateDateSpan(e,i);n[a]=r,r.isValid&&i.push({id:`temp-${a}`,country:"TEMP",startDate:e.start,endDate:e.end,days:t.differenceInDays(e.end,e.start)+1})}),n}rangesOverlap(e,a){return t.areIntervalsOverlapping({start:e.start,end:e.end},{start:a.start,end:a.end})}calculateConflictDetail(e,a,n){const i=e.start>a.start?e.start:a.start,r=e.end<a.end?e.end:a.end,s=t.differenceInDays(r,i)+1;return{tripId:n.id,tripCountry:n.country,conflictStart:i,conflictEnd:r,overlapDays:Math.max(0,s)}}shouldReportConflict(e,t,a){if(this.config.strictMode)return!0;if(this.config.allowSameDayTravel){if(t.start.getTime()===a.end.getTime()||t.end.getTime()===a.start.getTime())return!1}return!(this.config.allowBorderTransitions&&e.overlapDays<=1)}addOccupiedDatesFromTrip(e,a){const n=t.startOfDay(e.startDate),i=t.startOfDay(e.endDate);let r=new Date(n);for(;r<=i;)a.push(new Date(r)),r=new Date(r.getTime()+864e5)}generateValidationMessage(e){if(0===e.length)return"Dates are available";if(1===e.length){const t=e[0];return`Dates overlap with existing trip to ${t.tripCountry} (${t.overlapDays} day${1!==t.overlapDays?"s":""})`}return`Dates conflict with ${e.length} existing trips`}isValidDateRange(e){return!!(e&&e.start&&e.end)&&(!(!t.isValid(e.start)||!t.isValid(e.end))&&!(e.start>e.end))}isValidTrip(e){return!!(e&&e.startDate&&e.endDate)&&(!(!t.isValid(e.startDate)||!t.isValid(e.endDate))&&!(e.startDate>e.endDate))}updateConfig(e){this.config={...this.config,...e}}getConfig(){return{...this.config}}constructor(e={}){this.config={allowSameDayTravel:!0,allowBorderTransitions:!0,strictMode:!1,...e}}},e.RobustSchengenCalculator=a,e.SCHENGEN_COUNTRIES=n,e.SCHENGEN_COUNTRIES_COUNT=i,e.getCountriesForSelect=()=>n.map(e=>({value:e.code,label:`${e.flag} ${e.name}`,country:e})).sort((e,t)=>e.country.name.localeCompare(t.country.name)),e.getCountryByCode=e=>n.find(t=>t.code===e),e.getCountryByName=e=>n.find(t=>t.name.toLowerCase()===e.toLowerCase()),e.getEUMemberCountries=()=>n.filter(e=>e.isEUMember),e.getNonEUSchengenCountries=()=>n.filter(e=>!e.isEUMember)});
//# sourceMappingURL=index.umd.min.js.map
